<?php

module_load_include('inc', 'lingwo_dictionary', 'lingwo_dictionary.test');
module_load_include('inc', 'lingwo_data', 'lingwo_data.service');

require_once(drupal_get_path('module', 'lingwo_dictionary') .'/includes/3rdparty/PHPMockFunction/PHPMockFunction.php');

class LingwoDataImportWebTestCase extends LingwoDictionaryWebTestCase {
  public static $TestEntry = array(
    'headword' => 'czytać',
    'language' => 'pl',
    // TODO: how to deal with this?  POS heirarchy?  Reduction to simpler terms?
    //'pos' => 'transitive verb',
    'pos' => 'verb',

    'sources' => array(
      'pl.wiktionary.org' => array(
        // and so on ...
        'raw' => "== czytać ({{język polski}}) ==\n",
        // TODO: this isn't the correct copyright, figure out what it is..
        'copyright' => 'Copyright 2009 WikiMedia Foundation',
        'license' => 'CC-BY-SA-3.0',
        'url' => 'http://pl.wiktionary.org/wiki/czytać',
        'timestamp' => '2009-12-02T00:33:20Z',
      ),
      // here to test multiples!!
      'en.wiktionary.org' => array(
        'raw' => "==Polish==\n===Verb===\n",
        'copyright' => 'Copyright 2009 WikiMedia Foundation',
        'license' => 'CC-BY-SA-3.0',
        'url' => 'http://en.wiktionary.org/wiki/czytać',
        'timestamp' => '2009-11-02T14:48:20Z',
      ),
    ),

    'pron' => '\ˈʧɨtaʨ',

    'fields' => array(
      // we keep these in reverse order, so that we can see that our code re-arranges them.
      '*stem' => array(
        // TODO: we don't really need to specify type since, we can't create any fields that
        // don't exist anyway, and all the fields exist in the same namespace.
        'type' => 'form',
        'value' => 'czytaj',
        'automatic' => TRUE
      ),
      'conjugation' => array(
        'type' => 'option',
        'value' => 'third',
        'automatic' => FALSE
      ),
    ),

    // TODO: how does this format deal with entries with a single sense, but that has translations?
    // TODO: how does this format deal with translation clues?
    'senses' => array(
      array(
        'difference' => 'przebiegać wzrokiem lub dotykiem tekst w postaci liter lub ideogramów oraz znaków pisarskich i rozumieć treść przezeń przekazywaną',
        //'difference' => 'przebiegać wzrokiem lub dotykiem tekst w postaci liter lub ideogramów oraz znaków pisarskich i rozumieć treść przezeń',
        'example' => 'Codziennie rano czytam gazetę.'
      ),

      array(
        'difference' => 'mieć umiejętność rozumienia treści zawartych w rysunkach technicznych, schematach, mapach',
        'example' => 'Nie zabłądzimy, on umie czytać mapy i ma kompas.',
      ),

      array(
        'difference' => 'funkcja urządzenia technicznego polegająca na odkodowywaniu informacji',
        'example' => 'Przeczytać taką dyskietkę może tylko bardzo archaiczny komputer.'
      )
    ),

    'translations' => array(
      'en' => array(
        array(
          'trans' => array('read'),
          'clue'   => 'you know, reading books, maps and stuff',
        ),
        array('same_as' => 0),
        array(
          'trans' => array('read','decode','load'),
          'clue'   => 'when a computer "reads" something',
        )
      ),
      'be' => array(
        array(
          'trans' => array('чытаць')
        ),
        array(),
        array(),
      ),
      'hr' => array(
        array(
          'trans' => array('čitati')
        ),
        array(),
        array(),
      ),
    ),
  );

  public static function getInfo() {
    return array(
      'name' => 'lingwo_data - Import Web Tests',
      'description' => "Test lingwo_data's import functionality (Web Tests)",
      'group' => 'Lingwo Dictionary',
    );
  }

  public function setUp() {
    parent::setUp(
      // just new deps for these tests
      'lingwo_data',
      'text',
      'fieldgroup',
      'content_multigroup',

      // deps for lingwo_fields
      'ahah_helper',
      'lingwo_language',
      'lingwo_fields',

      // deps for lingwo_senses
      'lingwo_senses'
    );

    // create senses field
    $this->createField(array(
      'label'       => 'Senses',
      'field_name'  => 'senses',
      'type'        => 'lingwo_senses',
      'widget_type' => 'lingwo_senses_widget',
      'multiple'    => 1
    ));
    lingwo_data_settings('field_senses', 'field_senses');

    // create senses field
    $this->createField(array(
      'label'       => 'Fields',
      'field_name'  => 'fields',
      'type'        => 'lingwo_fields',
      'widget_type' => 'lingwo_fields_widget',
      'multiple'    => 1
    ));
    lingwo_data_settings('field_fields', 'field_fields');

    // create field group for source elements
    $this->createFieldGroup(array(
      'group_type' => 'multigroup',
      'group_name' => 'group_sources',
      'label'      => 'Sources',
      'settings'   => array(
        'multigroup' => array(
          'required' => FALSE,
          'multiple' => 1,
        )
      )
    ));

    // create a CCK fields to save pron and source
    $field_names = array(
      'pron',
      'source_name',
      'source_url',
      'source_copyright',
      'source_license',
      'source_raw',
      'source_timestamp',
    );
    foreach ($field_names as $fn) {
      $edit = array(
        'label'       => $fn,
        'field_name'  => $fn,
        'type'        => 'text',
        'widget_type' => 'text_textfield',
      );
      if (preg_match('/^source_/', $fn)) {
        $edit['parent'] = 'group_sources';
      }
      /*
      else {
        $edit['multiple'] = 1;
      }
      */
      if ($fn == 'source_raw') {
        $edit['widget_type'] = 'text_textarea';
      }

      $this->createField($edit);
      lingwo_data_settings("field_$fn", "field_$fn");
    }
  }

  public function testServiceUpdateEntry() {
    $data = json_encode(self::$TestEntry);

    // send the entry to the service
    $_nid = lingwo_data_service_update_entry($data);
    //$this->fail(print_r($_nid, TRUE));
    $this->drupalGet("node/$_nid/edit");
    $this->assertFieldByName('title', 'czytać');
    $this->assertFieldByName('language', 'pl');
    // TODO: we need a helper function to do this one up
    //$this->assertFieldByName("taxonomy[$entry_type]", XX);

    $nid = lingwo_dictionary_entry_lookup('czytać', 'pl', 'verb');
    $this->assertNotNull($nid);
    $this->assertEqual($nid, $_nid);

    $node = node_load($nid);
    //$this->pass(print_r($node, TRUE));
    $this->assertEqual($node->imported, TRUE);

    // verify pron
    $this->assertEqual($node->field_pron[0]['value'], '\ˈʧɨtaʨ');

    // verify first source
    $this->assertEqual($node->field_source_name[0]['value'], "pl.wiktionary.org");
    $this->assertEqual($node->field_source_raw[0]['value'], "== czytać ({{język polski}}) ==\n");
    $this->assertEqual($node->field_source_copyright[0]['value'], 'Copyright 2009 WikiMedia Foundation');
    $this->assertEqual($node->field_source_license[0]['value'], 'CC-BY-SA-3.0');
    $this->assertEqual($node->field_source_url[0]['value'], 'http://pl.wiktionary.org/wiki/czytać');
    $this->assertEqual($node->field_source_timestamp[0]['value'], '2009-12-02T00:33:20Z');

    // verify second source
    $this->assertEqual($node->field_source_name[1]['value'], "en.wiktionary.org");
    $this->assertEqual($node->field_source_raw[1]['value'], "==Polish==\n===Verb===\n");
    $this->assertEqual($node->field_source_copyright[1]['value'], 'Copyright 2009 WikiMedia Foundation');
    $this->assertEqual($node->field_source_license[1]['value'], 'CC-BY-SA-3.0');
    $this->assertEqual($node->field_source_url[1]['value'], 'http://en.wiktionary.org/wiki/czytać');
    $this->assertEqual($node->field_source_timestamp[1]['value'], '2009-11-02T14:48:20Z');

    // verify fields (1)
    $this->assertEqual($node->field_fields[0]['name'], 'conjugation');
    $this->assertEqual($node->field_fields[0]['type'], 'option');
    $this->assertEqual($node->field_fields[0]['value'], 'third');
    $this->assertEqual($node->field_fields[0]['automatic'], FALSE);
    // verify fields (2)
    $this->assertEqual($node->field_fields[1]['name'], '*stem');
    $this->assertEqual($node->field_fields[1]['type'], 'form');
    $this->assertEqual($node->field_fields[1]['value'], 'czytaj');
    $this->assertEqual($node->field_fields[1]['automatic'], TRUE);

    // verify senses
    $this->assertEqual($node->field_senses[0]['data']['difference'], 'przebiegać wzrokiem lub dotykiem tekst w postaci liter lub ideogramów oraz znaków pisarskich i rozumieć treść przezeń przekazywaną');
    $this->assertEqual($node->field_senses[0]['data']['example'], 'Codziennie rano czytam gazetę.');
    $this->assertEqual($node->field_senses[1]['data']['difference'], 'mieć umiejętność rozumienia treści zawartych w rysunkach technicznych, schematach, mapach');
    $this->assertEqual($node->field_senses[1]['data']['example'], 'Nie zabłądzimy, on umie czytać mapy i ma kompas.');
    $this->assertEqual($node->field_senses[2]['data']['difference'], 'funkcja urządzenia technicznego polegająca na odkodowywaniu informacji');
    $this->assertEqual($node->field_senses[2]['data']['example'], 'Przeczytać taką dyskietkę może tylko bardzo archaiczny komputer.');

    // verify translations
    $tnid_list = translation_node_get_translations($nid);
    $tnode = node_load($tnid_list['en']->nid);
    $this->assertEqual($tnode->imported, TRUE);
    $this->assertEqual($tnode->field_senses[0]['data']['trans'], array('read', '', ''));
    $this->assertEqual($tnode->field_senses[0]['data']['clue'], 'you know, reading books, maps and stuff');
    $this->assertEqual($tnode->field_senses[1]['data']['trans'], array('', '', ''));
    $this->assertEqual($tnode->field_senses[1]['data']['clue'], '');
    $this->assertEqual($tnode->field_senses[2]['data']['trans'], array('read','decode','load'));
    $this->assertEqual($tnode->field_senses[2]['data']['clue'], 'when a computer "reads" something');

    // attempt to update the entry again and check that it doesn't take (because it hasn't changed)
    node_load(0, NULL, TRUE);
    lingwo_data_service_update_entry($data);
    $this->assertEqual(node_load($nid)->vid, $node->vid);
  }
}

class LingwoDataImportUnitTestCase extends DrupalUnitTestCase {
  public static function getInfo() {
    return array(
      'name' => 'lingwo_data - Import',
      'description' => "Test lingwo_data import functionality",
      'group' => 'Lingwo Dictionary',
    );
  }

  public function setUp() {
    parent::setUp('lingwo_data', 'lingwo_senses', 'lingwo_fields', 'lingwo_language');
    
  }

  public function tearDown() {
    parent::tearDown();

    PHPMockFunction::deactivateAll();
  }

  public function testProcessSource() {
    // set up our mock functions!
    $lingwo_data_settings = PHPMockFunction::mock('lingwo_data_settings');
    $lingwo_data_settings->expects(InvocationRestriction::once())
      ->with('field_pron')
      ->will(WillAction::returnValue('field_pron'));
    $lingwo_data_settings->expects(InvocationRestriction::once())
      ->with('field_senses')
      ->will(WillAction::returnValue('field_senses'));
    $lingwo_data_settings->expects(InvocationRestriction::once())
      ->with('field_fields')
      ->will(WillAction::returnValue('field_fields'));

    $lingwo_language_fields = PHPMockFunction::mock('lingwo_language_fields');
    $lingwo_language_fields->expects(InvocationRestriction::once())
      ->with('zzz', 'noun')
      ->will(WillAction::returnValue(array(
        array(
          'type' => 'option',
          'name' => 'first',
        ),
        array(
          'type' => 'form',
          'name' => 'second',
        )
    )));

    $res = _lingwo_data_import_process_source(array(
      'language' => 'zzz',
      'pos'      => 'noun',
      'pron' => 'pron',
      'senses' => array(
        array(
          'difference' => 'diff1',
          'example' => 'example'
        ),
        array(
          'difference' => 'diff2'
        )
      ),
      'fields' => array(
        'second' => array(
          'value' => 'thinger',
          'automatic' => FALSE,
        )
      )
    ));

    // verify each part
    $this->assertEqual($res['pron'], array(array('value' => 'pron')));
    $this->assertEqual($res['senses'], array(
      array(
        'data' => array(
          'difference' => 'diff1',
          'example'    => 'example',
        )
      ),
      array(
        'data' => array(
          'difference' => 'diff2',
        )
      )
    ));
    $this->assertEqual($res['fields'], array(
      array(
        'type' => 'option',
        'name' => 'first',
        'value' => NULL,
        'automatic' => TRUE
      ),
      array(
        'type' => 'form',
        'name' => 'second',
        'value' => 'thinger',
        'automatic' => FALSE
      )
    ));
  }
}

