<?php

module_load_include('inc', 'lingwo_dictionary', 'lingwo_dictionary.test');
module_load_include('inc', 'lingwo_data', 'lingwo_data.service');

require_once(drupal_get_path('module', 'lingwo_dictionary') .'/includes/3rdparty/PHPMockFunction/PHPMockFunction.php');

class LingwoDataImportWebTestCase extends LingwoDictionaryWebTestCase {
  public static $TestEntry = array(
    'headword' => 'czytać',
    'language' => 'pl',
    // TODO: how to deal with this?  POS heirarchy?  Reduction to simpler terms?
    //'pos' => 'transitive verb',
    'pos' => 'verb',

    'sources' => array(
      'pl.wiktionary.org' => array(
        // and so on ...
        'raw' => "== czytać ({{język polski}}) ==\n",
        // TODO: this isn't the correct copyright, figure out what it is..
        'copyright' => 'Copyright 2009 WikiMedia Foundation',
        'license' => 'CC-BY-SA-3.0',
        'url' => 'http://pl.wiktionary.org/wiki/czytać',
        'timestamp' => '2009-12-02T00:33:20Z',
      ),
      // here to test multiples!!
      'en.wiktionary.org' => array(
        'raw' => "==Polish==\n===Verb===\n",
        'copyright' => 'Copyright 2009 WikiMedia Foundation',
        'license' => 'CC-BY-SA-3.0',
        'url' => 'http://en.wiktionary.org/wiki/czytać',
        'timestamp' => '2009-11-02T14:48:20Z',
      ),
    ),

    'pron' => '\ˈʧɨtaʨ',

    'fields' => array(
      // we keep these in reverse order, so that we can see that our code re-arranges them.
      '*stem' => array(
        // TODO: we don't really need to specify type since, we can't create any fields that
        // don't exist anyway, and all the fields exist in the same namespace.
        'type' => 'form',
        'value' => 'czytaj',
        'automatic' => TRUE
      ),
      'conjugation' => array(
        'type' => 'option',
        'value' => 'third',
        'automatic' => FALSE
      ),
    ),

    // TODO: how does this format deal with entries with a single sense, but that has translations?
    // TODO: how does this format deal with translation clues?
    'senses' => array(
      array(
        'difference' => 'przebiegać wzrokiem lub dotykiem tekst w postaci liter lub ideogramów oraz znaków pisarskich i rozumieć treść przezeń przekazywaną',
        //'difference' => 'przebiegać wzrokiem lub dotykiem tekst w postaci liter lub ideogramów oraz znaków pisarskich i rozumieć treść przezeń',
        'example' => 'Codziennie rano czytam gazetę.'
      ),

      array(
        'difference' => 'mieć umiejętność rozumienia treści zawartych w rysunkach technicznych, schematach, mapach',
        'example' => 'Nie zabłądzimy, on umie czytać mapy i ma kompas.',
      ),

      array(
        'difference' => 'funkcja urządzenia technicznego polegająca na odkodowywaniu informacji',
        'example' => 'Przeczytać taką dyskietkę może tylko bardzo archaiczny komputer.'
      )
    ),

    'translations' => array(
      'en' => array(
        'senses' => array(
          array(
            'trans' => array('read'),
            'clue'   => 'you know, reading books, maps and stuff',
          ),
          array('same_as' => 0),
          array(
            'trans' => array('read','decode','load'),
            'clue'   => 'when a computer "reads" something',
          )
        )
      ),
      'be' => array(
        'senses' => array(
          array(
            'trans' => array('чытаць')
          ),
          array(),
          array(),
        )
      ),
      'hr' => array(
        'senses' => array(
          array(
            'trans' => array('čitati')
          ),
          array(),
          array(),
        )
      ),
    ),
  );

  public static function getInfo() {
    return array(
      'name' => 'lingwo_data - Import Web Tests',
      'description' => "Test lingwo_data's import functionality (Web Tests)",
      'group' => 'Lingwo Dictionary',
    );
  }

  public function setUp() {
    parent::setUp(
      // just new deps for these tests
      'lingwo_data',
      'text',
      'fieldgroup',
      'content_multigroup',

      // deps for lingwo_fields
      'ahah_helper',
      'lingwo_language',
      'lingwo_fields',

      // deps for lingwo_senses
      'lingwo_senses'
    );

    // create senses field
    $this->createField(array(
      'label'       => 'Senses',
      'field_name'  => 'senses',
      'type'        => 'lingwo_senses',
      'widget_type' => 'lingwo_senses_widget',
      'multiple'    => 1
    ));
    lingwo_data_settings('field_senses', 'field_senses');

    // create senses field
    $this->createField(array(
      'label'       => 'Fields',
      'field_name'  => 'fields',
      'type'        => 'lingwo_fields',
      'widget_type' => 'lingwo_fields_widget',
      'multiple'    => 1
    ));
    lingwo_data_settings('field_fields', 'field_fields');

    // create field group for source elements
    $this->createFieldGroup(array(
      'group_type' => 'multigroup',
      'group_name' => 'group_sources',
      'label'      => 'Sources',
      'settings'   => array(
        'multigroup' => array(
          'required' => FALSE,
          'multiple' => 1,
        )
      )
    ));

    // create a CCK fields to save pron and source
    $field_names = array(
      'pron',
      'source_name',
      'source_url',
      'source_copyright',
      'source_license',
      'source_raw',
      'source_timestamp',
    );
    foreach ($field_names as $fn) {
      $edit = array(
        'label'       => $fn,
        'field_name'  => $fn,
        'type'        => 'text',
        'widget_type' => 'text_textfield',
      );
      if (preg_match('/^source_/', $fn)) {
        $edit['parent'] = 'group_sources';
      }
      /*
      else {
        $edit['multiple'] = 1;
      }
      */
      if ($fn == 'source_raw') {
        $edit['widget_type'] = 'text_textarea';
      }

      $this->createField($edit);
      lingwo_data_settings("field_$fn", "field_$fn");
    }
  }

  private function outputWatchdog() {
    $res = db_query("SELECT * FROM {watchdog} ORDER BY timestamp DESC LIMIT 10");
    while($o = db_fetch_object($res)) {
      $this->fail(print_r($o, TRUE));
    }
  }

  public function testServiceUpdateEntry() {
    $data = json_encode(self::$TestEntry);

    // send the entry to the service
    $_nid = lingwo_data_service_update_entry($data);
    //$this->fail(print_r($_nid, TRUE));
    $this->drupalGet("node/$_nid/edit");
    $this->assertFieldByName('title', 'czytać');
    $this->assertFieldByName('language', 'pl');
    // TODO: we need a helper function to do this one up
    //$this->assertFieldByName("taxonomy[$entry_type]", XX);

    $nid = lingwo_dictionary_entry_lookup('czytać', 'pl', 'verb');
    $this->assertNotNull($nid);
    $this->assertEqual($nid, $_nid);

    $this->drupalGet('node/add/'. lingwo_dictionary_settings('entry_content_type'));
    //$this->outputWatchdog();

    $node = node_load($nid);
    //$this->pass(print_r($node, TRUE));
    $this->assertEqual($node->imported, TRUE);

    // verify pron
    $this->assertEqual($node->field_pron[0]['value'], '\ˈʧɨtaʨ');

    // verify first source
    $this->assertEqual($node->field_source_name[0]['value'], "pl.wiktionary.org");
    $this->assertEqual($node->field_source_raw[0]['value'], "== czytać ({{język polski}}) ==\n");
    $this->assertEqual($node->field_source_copyright[0]['value'], 'Copyright 2009 WikiMedia Foundation');
    $this->assertEqual($node->field_source_license[0]['value'], 'CC-BY-SA-3.0');
    $this->assertEqual($node->field_source_url[0]['value'], 'http://pl.wiktionary.org/wiki/czytać');
    $this->assertEqual($node->field_source_timestamp[0]['value'], '2009-12-02T00:33:20Z');

    // verify second source
    $this->assertEqual($node->field_source_name[1]['value'], "en.wiktionary.org");
    $this->assertEqual($node->field_source_raw[1]['value'], "==Polish==\n===Verb===\n");
    $this->assertEqual($node->field_source_copyright[1]['value'], 'Copyright 2009 WikiMedia Foundation');
    $this->assertEqual($node->field_source_license[1]['value'], 'CC-BY-SA-3.0');
    $this->assertEqual($node->field_source_url[1]['value'], 'http://en.wiktionary.org/wiki/czytać');
    $this->assertEqual($node->field_source_timestamp[1]['value'], '2009-11-02T14:48:20Z');

    // verify fields (1)
    $this->assertEqual($node->field_fields[0]['name'], 'conjugation');
    $this->assertEqual($node->field_fields[0]['type'], 'option');
    $this->assertEqual($node->field_fields[0]['value'], 'third');
    $this->assertEqual($node->field_fields[0]['automatic'], FALSE);
    // verify fields (2)
    $this->assertEqual($node->field_fields[1]['name'], '*stem');
    $this->assertEqual($node->field_fields[1]['type'], 'form');
    $this->assertEqual($node->field_fields[1]['value'], 'czytaj');
    $this->assertEqual($node->field_fields[1]['automatic'], TRUE);

    // verify senses
    $this->assertEqual($node->field_senses[0]['data']['difference'], 'przebiegać wzrokiem lub dotykiem tekst w postaci liter lub ideogramów oraz znaków pisarskich i rozumieć treść przezeń przekazywaną');
    $this->assertEqual($node->field_senses[0]['data']['example'], 'Codziennie rano czytam gazetę.');
    $this->assertEqual($node->field_senses[1]['data']['difference'], 'mieć umiejętność rozumienia treści zawartych w rysunkach technicznych, schematach, mapach');
    $this->assertEqual($node->field_senses[1]['data']['example'], 'Nie zabłądzimy, on umie czytać mapy i ma kompas.');
    $this->assertEqual($node->field_senses[2]['data']['difference'], 'funkcja urządzenia technicznego polegająca na odkodowywaniu informacji');
    $this->assertEqual($node->field_senses[2]['data']['example'], 'Przeczytać taką dyskietkę może tylko bardzo archaiczny komputer.');

    // verify translations
    $tnid_list = translation_node_get_translations($nid);
    $tnode = node_load($tnid_list['en']->nid);
    $this->assertEqual($tnode->imported, TRUE);
    $this->assertEqual($tnode->field_senses[0]['data']['trans'], array('read', '', ''));
    $this->assertEqual($tnode->field_senses[0]['data']['clue'], 'you know, reading books, maps and stuff');
    $this->assertEqual($tnode->field_senses[1]['data']['trans'], array('', '', ''));
    $this->assertEqual($tnode->field_senses[1]['data']['clue'], '');
    $this->assertEqual($tnode->field_senses[2]['data']['trans'], array('read','decode','load'));
    $this->assertEqual($tnode->field_senses[2]['data']['clue'], 'when a computer "reads" something');

    // attempt to update the entry again and check that it doesn't take (because it hasn't changed)
    node_load(0, NULL, TRUE);
    lingwo_data_service_update_entry($data);
    $this->assertEqual(node_load($nid)->vid, $node->vid);
  }

  // test a problem entry
  /*
  public function testStrzelec() {
    $data = '{"headword":"strzelec","language":"pl","sources":{"pl.wiktionary.org":{"raw":"== strzelec ({{język polski}}) ==\n{{wymowa}}\n{{znaczenia}}\n\'\'rzeczownik, rodzaj męski\'\'\n: (1.1) [[osoba]] [[umieć|umiejąca]] [[się]] [[posługiwać]] [[broń palna|bronią palną]], [[łuk]]iem [[lub]] [[inny|inną]] [[broń|bronią]] [[miotać|miotającą]]\n: (1.2) [[żołnierz]] [[wyspecjalizować|wyspecjalizowany]] [[w]] [[strzelanie|strzelaniu]]\n: (1.3) [[sportowiec]] [[specjalizować|specjalizujący]] [[się]] [[w]] strzelaniu [[z]] [[ręczny|ręcznej]] broni palnej\n: (1.4) \'\'w [[sport#sport (język polski)|sporcie]]:\'\' [[zawodnik]], [[który]] [[strzelać|strzelił]] [[bramka|bramkę]]\n{{odmiana|polski}} {{lp}} strzelec, strzelca, strzelcowi, strzelca, strzelcem, strzelcu, strzelcu (strzelcze); {{lm}} strzelcy, strzelców, strzelcom, strzelców, strzelcami, strzelcach, strzelcy\n{{przykłady}}\n: (1.1)\n{{składnia}}\n{{kolokacje}}\n{{synonimy}} (1.1) [[myśliwy]], (1.3-4) [[zawodnik]]\n{{antonimy}}\n{{pokrewne}} {{przym}} [[strzelecki]]; {{rzecz}} [[strzelczyni]], [[strzelectwo]], [[strzelnica]], [[strzelanie]], [[strzelanina]], [[strzelba]] {{czas}} [[strzelać]];\n{{frazeologia}} (1.2) [[strzelec wyborowy]]; [[wolny strzelec]]\n{{etymologia}}\n{{uwagi}}\n{{tłumaczenia}}\n* angielski: (1.1) [[shooter]], [[shot]]; (1.2) [[rifleman]], [[fusilier]], [[gunner]]; (1.3) [[shooter]]; (1.4) [[scorer]], ([[good]]) [[kick]]\n* duński: (1.1) [[skytte]] {{w}}; (1.4) [[målscorer]] {{w}}\n* francuski: (1.1) un [[tireur]], un [[chasseur]]\n* łaciński: (1.1-3) [[sagittarius]] {{m}}\n* niemiecki: (1.1) [[Schütze]] {{m}}; (1.2) [[Jäger]] {{m}}; (1.4) [[Troschütze]] {{m}}","url":"http://pl.wiktionay.org/wiki/strzelec","license":"CC-BY-SA","timestamp":"2009-08-06T08:14:15Z"}},"pos":"noun","fields":{"gender":{"value":"masculine","automatic":false},"virile":{"value":false,"automatic":true},"animate":{"value":false,"automatic":true},"*stem":{"value":"strzelec","automatic":true},"*stem.singular":{"value":"strzelec","automatic":true},"*stem.plural":{"value":"strzelec","automatic":true},"nominative.singular":{"value":"strzelec","automatic":true},"nominative.plural":{"value":"strzelece","automatic":true},"accusative.singular":{"value":"strzelec","automatic":true},"accusative.plural":{"value":"strzelece","automatic":true},"genitive.singular":{"value":"strzelecu","automatic":true},"genitive.plural":{"value":"strzeleców","automatic":true},"instrumental.singular":{"value":"strzelecem","automatic":true},"instrumental.plural":{"value":"strzelecami","automatic":true},"locative.singular":{"value":"strzelecu","automatic":true},"locative.plural":{"value":"strzelecach","automatic":true}},"translations":{"en":{"senses":[{"trans":["shooter","shot; rifleman","fusilier","gunner; shooter; scorer","(good) kick"]}]},"da":{"senses":[{"trans":["skytte (w); målscorer (w)"]}]},"fr":{"senses":[{"trans":["un tireur","un chasseur"]}]},"la":{"senses":[{"trans":["sagittarius (m)"]}]},"de":{"senses":[{"trans":["Schütze (m); Jäger (m); Troschütze (m)"]}]}},"senses":[{"difference":"osoba umiejąca się posługiwać bronią palną, łukiem lub inną bronią miotającą","example":""},{"difference":"żołnierz wyspecjalizowany w strzelaniu"},{"difference":"sportowiec specjalizujący się w strzelaniu z ręcznej broni palnej"},{"difference":"w sporcie: zawodnik, który strzelił bramkę"}]}';

    $nid = lingwo_data_service_update_entry($data);
    $this->fail($nid);
  }
  */
}

class LingwoDataImportUnitTestCase extends DrupalUnitTestCase {
  public static function getInfo() {
    return array(
      'name' => 'lingwo_data - Import',
      'description' => "Test lingwo_data import functionality",
      'group' => 'Lingwo Dictionary',
    );
  }

  public function setUp() {
    parent::setUp('lingwo_data', 'lingwo_senses', 'lingwo_fields', 'lingwo_language');
    
  }

  public function tearDown() {
    parent::tearDown();

    PHPMockFunction::deactivateAll();
  }

  public function testProcessLanguage() {
    $language_list = PHPMockFunction::mock('language_list');
    $language_list->expects(InvocationRestriction::once())
      ->with()
      ->will(WillAction::returnValue(array(
        (object)array(
          'language' => 'en',
          'enabled'  => FALSE,
        ),
        (object)array(
          'language' => 'zzz',
          'enabled'  => TRUE
        )
    )));

    $languages = _lingwo_data_import_process_language(array(
      'language' => 'zzz'
    ));

    $this->assertEqual($languages, array('zzz' => TRUE));
  }

  public function testProcessTaxonomy() {
    $pos_vid = 27;

    $lingwo_dictionary_settings = PHPMockFunction::mock('lingwo_dictionary_settings');
    $lingwo_dictionary_settings->expects(InvocationRestriction::once())
      ->with('pos_vocabulary')
      ->will(WillAction::returnValue($pos_vid));

    $taxonomy_get_tree = PHPMockFunction::mock('taxonomy_get_tree');
    $taxonomy_get_tree->expects(InvocationRestriction::once())
      ->with($pos_vid)
      ->will(WillAction::returnValue(array(
        (object)array(
          'name' => 'Verb',
          'tid'  => 1
        ),
        (object)array(
          'name' => 'Noun',
          'tid'  => 2
        )
    )));

    $taxonomy = _lingwo_data_import_process_taxonomy(array(
      'pos' => 'noun',
    ));

    $this->assertEqual($taxonomy, array($pos_vid => 2));
  }

  public function testProcessSources() {
    $sources = _lingwo_data_import_process_sources(array(
      'sources' => array(
        'pl.wiktionary.org' => array(
          'url' => 'http://pl.wiktionary.org',
          'license' => 'CC-BY-SA-3.0',
        ),
        'www.Open-Dictionaries.com' => array(
          'copyright' => 'Copyright 2010 Jerzy Kazojć',
          'timestamp' => '2010-01-20T00:00:00Z',
        )
      )
    ));

    $this->assertEqual($sources[0], array(
      'source_name'      => 'pl.wiktionary.org',
      'source_url'       => 'http://pl.wiktionary.org',
      'source_copyright' => NULL,
      'source_license'   => 'CC-BY-SA-3.0',
      'source_raw'       => NULL,
      'source_timestamp' => NULL,
    ));
    $this->assertEqual($sources[1], array(
      'source_name'      => 'www.Open-Dictionaries.com',
      'source_url'       => NULL,
      'source_copyright' => 'Copyright 2010 Jerzy Kazojć',
      'source_license'   => NULL,
      'source_raw'       => NULL,
      'source_timestamp' => '2010-01-20T00:00:00Z',
    ));
  }

  public function testProcessOriginal() {
    $lingwo_data_settings = PHPMockFunction::mock('lingwo_data_settings');
    $lingwo_data_settings->expects(InvocationRestriction::once())
      ->with('field_pron')
      ->will(WillAction::returnValue('field_pron'));
    $lingwo_data_settings->expects(InvocationRestriction::once())
      ->with('field_senses')
      ->will(WillAction::returnValue('field_senses'));
    $lingwo_data_settings->expects(InvocationRestriction::once())
      ->with('field_fields')
      ->will(WillAction::returnValue('field_fields'));

    $lingwo_language_fields = PHPMockFunction::mock('lingwo_language_fields');
    $lingwo_language_fields->expects(InvocationRestriction::once())
      ->with('zzz', 'noun')
      ->will(WillAction::returnValue(array(
        array(
          'type' => 'option',
          'name' => 'first',
        ),
        array(
          'type' => 'form',
          'name' => 'second',
        )
    )));

    $res = _lingwo_data_import_process_original(array(
      'language' => 'zzz',
      'pos' => 'noun',
      'pron' => 'pron',
      'senses' => array(
        array(
          'difference' => 'diff1',
          'example' => 'example'
        ),
        array(
          'difference' => 'diff2'
        )
      ),
      'fields' => array(
        'second' => array(
          'value' => 'thinger',
          'automatic' => FALSE,
        )
      )
    ));

    // verify each part
    $this->assertEqual($res['pron'], array('pron'));
    $this->assertEqual($res['senses'], array(
      array(
        'difference' => 'diff1',
        'example'    => 'example',
      ),
      array(
        'difference' => 'diff2',
      )
    ));
    $this->assertEqual($res['fields'], array(
      array(
        'type' => 'option',
        'name' => 'first',
        'value' => NULL,
        'automatic' => TRUE
      ),
      array(
        'type' => 'form',
        'name' => 'second',
        'value' => 'thinger',
        'automatic' => FALSE
      )
    ));
  }

  public function testSetFields() {
    $lingwo_data_settings = PHPMockFunction::mock('lingwo_data_settings');
    $lingwo_data_settings->expects(InvocationRestriction::once())
      ->with('field_pron')
      ->will(WillAction::returnValue('field_pron'));
    
    $lingwo_dictionary_settings = PHPMockFunction::mock('lingwo_dictionary_settings');
    $lingwo_dictionary_settings->expects(InvocationRestriction::once())
      ->with('entry_content_type')
      ->will(WillAction::returnValue('entry'));

    $content_fields = PHPMockFunction::mock('content_fields');
    $content_fields->expects(InvocationRestriction::once())
      ->with('field_pron', 'entry')
      ->will(WillAction::returnValue(array('type' => 'text')));

    $node = (object)array();
    _lingwo_data_import_set_fields($node, array(
      'pron' => array('blah')
    ));

    $this->assertEqual((array)$node, array(
      'imported_data' => 'a:1:{s:4:"pron";a:1:{i:0;s:4:"blah";}}',
      'field_pron' => array(
        array('value' => 'blah')
      )
    ));
  }

  public function testSetFieldsMultigroup() {
    $lingwo_data_settings = PHPMockFunction::mock('lingwo_data_settings');
    $lingwo_data_settings->expects(InvocationRestriction::once())
      ->with('field_source_url')
      ->will(WillAction::returnValue('field_source_url'));
    $lingwo_data_settings->expects(InvocationRestriction::once())
      ->with('field_source_name')
      ->will(WillAction::returnValue('field_source_name'));

    $lingwo_dictionary_settings = PHPMockFunction::mock('lingwo_dictionary_settings');
    $lingwo_dictionary_settings->expects(InvocationRestriction::exactly(2))
      ->with('entry_content_type')
      ->will(WillAction::returnValue('entry'));

    $content_fields = PHPMockFunction::mock('content_fields');
    $content_fields->expects(InvocationRestriction::once())
      ->with('field_source_url', 'entry')
      ->will(WillAction::returnValue(array('type' => 'text')));
    $content_fields->expects(InvocationRestriction::once())
      ->with('field_source_name', 'entry')
      ->will(WillAction::returnValue(array('type' => 'text')));
    
    $node = (object)array();
    _lingwo_data_import_set_fields_multigroup($node, array(
      array(
        'source_url' => 'url1',
        'source_name' => 'name1'
      ),
      array(
        'source_url' => 'url2',
        'source_name' => 'name2'
      )
    ));

    $this->assertEqual((array)$node, array(
      'field_source_url' => array(
        array('value' => 'url1'),
        array('value' => 'url2'),
      ),
      'field_source_name' => array(
        array('value' => 'name1'),
        array('value' => 'name2'),
      )
    ));
  }
}

